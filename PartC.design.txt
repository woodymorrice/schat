CMPT332 - Group 14
Phong Thanh Nguyen (David) - wdz468 - 11310824
Woody Morrice - wam553 - 11071060

# Design Details 
Styling: we agreed that we will follow QEMU styles as recommended on class.

# list.h

Contains all requested functions given in A1-Final.txt specification, each functions will have comments
on top to describe the tasks that it needs to carry out. 
For structure definition of LIST: 
    We have: 
        struct NODE *headPointer;       // pointer points to fist NODE (head)
        struct NODE *tailPointer:       // pointer points to last NODE (tail)
        struct NODE *currentItem;       // pointer points to current NODE
        int totalItem;                  // tells us how many items / nodes this LIST contains
        

For structure definition of NODE:
    We have: 
        struct NODE *prevNode;          // pointer points to the previous NODE of the current NODE
        struct NODE *nextNode;          // pointer points to the next NODE of the current NODE
        void *dataType;                 // (dataType) or (item), hold the actual C data type

# list_adders.c

LIST *ListCreate ()
    Receive no parameters, at first we make all of the members in LIST becomes NULL, except totalItem = 0.
    This function will make a new, empty list and returns its reference on success. Otherwise, return NULL.

@Pre-condition: list must not be NULL
int ListCount (LIST *list) 
    Receive a pointer to LIST and request this function to return the number of items in list 
    by calling (list->totalItem). 

int ListAdd (LIST *list, void* item)

    Creates 2 struct NODE * variables (curItem & curNext) one for holding 

    the pointer to the currentItem and one for pointer points to the 

    nextNode (or next item of currentItem). 

    If (list->totalItem) is smaller than the constant MAX_ITEM then

    for LIST that has size of 0, simply make everything point to the 

    (item). For currentItem that is at tail of LIST, call 

    ListAppend(list, item) to add the new item to the end. Otherwise

    add the (item) in the middle, plus (totalItem) by 1, adjust the 
    
    current pointer and return 0 on success, -1 on failure. 

int ListInsert(LIST *list, void* item)

    Creates 2 struct NODE * variables (curItem & curNext) one for holding

    the pointer to the currentItem and one for pointer points to the

    nextNode (or next item of currentItem).

    If (list->totalItem) is smaller than the constant MAX_ITEM then

    for LIST that has size of 0, simply make everything point to the

    (item). For currentItem that is at head of LIST, call

    ListPrepend(list, item) to add the new item to the head. Otherwise

    add the (item) in the middle, plus (totalItem) by 1, adjust the

    current pointer and return 0 on success, -1 on failure.

@Pre-condition: list must not be NULL, if LIST is NULL, simply return
nothing
void ListConCat(LIST *list1, LIST *list2) 
    Simply make the tail of (list1->nextNode) points to the head of (list2)
    
    and vice versa for head of (list2->prevNode) to tail of (list1). Change

    the tail of (list1) equals to last item of (list2). Combine the size.

    Delete(list2). 

@Pre-condition: list must not be NULL, if LIST is NULL, simply return
nothing
int ListAppend (LIST *list, void *item)

    Create (struct NODE *prevTail) to hold the current pointer to tail.

    If (list->totalItem) is smaller than the constant MAX_ITEM then

    for LIST that has size of 0, simply make everything point to the

    (item). For currentItem that is at somewhere not tail, call

    ListLast(list, item) to go to the tail and make the new tail, plus 

    (totalItem) by 1, adjust the current pointer and return 0 on success, 

    -1 on failure.

@Pre-condition: list must not be NULL, if LIST is NULL, simply return
nothing
int ListPrepend (LIST *list, void *item)

    Create (struct NODE *prevHead) to hold the current pointer to head.

    If (list->totalItem) is smaller than the constant MAX_ITEM then

    for LIST that has size of 0, simply make everything point to the

    (item). For currentItem that is at somewhere not tail, call

    ListFirst(list, item) to go to the head and make the new head, plus

    (totalItem) by 1, adjust the current pointer and return 0 on success,

    -1 on failure.
    

# list_movers.c

@Pre-condition: list must not be NULL, if LIST is NULL, simply return
nothing
void *ListFirst (LIST *list)
    Receive a pointer to LIST and request this function to return first item    
    and make the list->currentItem points to the first item.

@Pre-condition: list must not be NULL, if LIST is NULL, simply return
nothing
void *ListLast (LIST *list)
    Receive a pointer to LIST and request this function to return last item

    and make the list->currentItem points to the last item.

@Pre-condition: list must not be NULL, if LIST is NULL, simply return
nothing
void *ListLast (LIST *list)
    Receive a pointer to LIST and request this function to return last item

    and make the list->currentItem points to the last item.

@Pre-condition: list must not be NULL, if LIST is NULL, simply return
nothing
void *ListNext (LIST *list)
    Receive a pointer to LIST and request this function to: 
    
    Here there are 3 scenarioes that can happen: 
    
        First, if the list only has 1 items (node) then simply return NULL.

        Second, if (list->currentItem) is at the last item in the LIST, we

        also return NULL.
    
        Finally, if (list->currentItem) is at middle of LIST or on an
    
        appropriate position, simply change (list->currentItem) to point
        
        to the next item and return its dataType.

@Pre-condition: list must not be NULL, if LIST is NULL, simply return
nothing
void *ListPrev (LIST *list)
    Receive a pointer to LIST and request this function to:

    Here there are 3 scenarioes that can happen:

        First, if the list only has 1 items (node) then simply return NULL.

        Second, if (list->currentItem) is at the first item in the LIST, we

        also return NULL.

        Finally, if (list->currentItem) is at middle of LIST or on an

        appropriate position, simply change (list->currentItem) to point

        to the previous item and return its dataType.


@Pre-condition: list must not be NULL, if LIST is NULL, simply return
nothing or NULL.
void *ListCurr (LIST *list)
    Receive a pointer to LIST and request this function to return 
    
    (list->currentItem)->dataType.


@Pre-condition: list must not be NULL, if LIST is NULL, simply return
nothing
void *ListSearch (LIST *list, int (* comparator)(void *item1, void* item2),

    void* comparisonArg)
    Receive a pointer to LIST and request this function to:

    Create struct NODE *itemToCompare to hold the referenc of (list->currentItem)


    Keep searching until the function comparator(compariArg, itemToCompare->dataType)

    equal to 1 (1 means success, 0 means failure) and current pointer is
    
    left at the matched item and the pointer to that item is return.

    
    If no match is found, current pointer is left at the end of list and 

    return NULL;


# list_removers.c

void *ListRemove(LIST *list)

    Receive a pointer to LIST and ask the functions to do the following: 
    
    Create (struct NODE *item1) to hold the pointer to the currentItem 

    then there are 4 scenarioes that can happen: 

    First, if the LIST only has 1 item, simply make everything NULL and 
    
    minus (totalItem) by 1, plus return the removed dataType.

    
    Second, if current pointer is at the head of LIST, delete the oldHead

    and make the (oldHead->nextNode) to become the new head,adjust the

    current pointer. Minus (list->totalItem) by 1 and return 

    (oldHead->dataType). 

    
    Third, if current pointer is at the tail of LIST, delete the oldTail

    and make the (oldTail->nextNode) to become the new tail, adjust the

    current pointer. Minus (list->totalItem) by 1 and return

    (oldTail->dataType).

    
    Finally, if current pointer is at appropriate position in LIST, delete 

    the currentItem and adjust the current pointer. Minus (list->totalItem) 

    by 1 and return (list->currentItem)->dataType. 


void ListFree (LIST *list, void (*itemFree)(void* itemToBeFreed))

    Create boolean value named (empty) and pointer (itemToRemove) to hold

    the current item. After that we generate a while-loop that uses

    itemFree() until all the nodes are freed. Finally we set the members

    of the (list) back to NULL and completely delete the list.

     
void *ListTrim(LIST *list)

    Receive pointer to a list  and return last item by calling 

    ListLast(list) to move the current pointer points to the tail of 

    LIST and take the item out of list. The current pointer shall be 

    the new last item in the list. 
     

