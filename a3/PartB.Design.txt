* CMPT332 - Group 14
* Phong Thanh Nguyen (David) - wdz468 - 11310824
* Woody Morrice - wam553 - 11071060

Copy-on-Write

getNumFreePages() Design
The design for this function is simple. I created an integer variable in the
kernel data structure called freecnt. kinit() initializes freecnt to 0 and 
calls freerange(), which in turn calls kfree() for each physical page as part 
of the initialization process of the physical memory. kfree() increments 
freecnt by 1, and kalloc decrements freecnt by 1. So when the list of free 
pages of physical memory is initialized (default xv6 behavior), freecnt is
incremented up to the total number of free pages on the system. I also created 
a function called nfree() in kalloc.c that returns freecnt. Any time freecnt 
is accessed (incremented, decremented, returned) the lock for the kernel data 
structure is acquired beforehand. The getNumFreePages() syscall is located in
sysproc.c and simply calls nfree().

Physical Page Reference Design
Section 3.5 of the xv6 book mentions that the physical memory data structure 
resides in the memory between the end of the kernel and PHYSTOP. memlayout.h
further clarifies that user pages reside from the defined KERNBASE to PHYSTOP.
Pages are 4096 (2^12) bytes according to the documentation, so I defined 
PGSZNBITS as 12 (no magic numbers), and NPAGES as 
(PHYSTOP - KERNBASE) >> PGSZNBITS (bit shifting instead of division because 
division is slow). Then I added an array to the kernel data structure called
refcnt[NPAGES]. The array is then indexed by physical address, and the index 
is calculated exactly the same way as the number of pages was calculated (but
with pa instead of PHYSTOP), which I defined in a macro in memlayout.h called
RCIND(pa).
freerange() initializes all page reference counts to 1 before kfree() is called
on each page. This is because kfree() decreases the reference count of any page
it is called on, and checks if the reference count is less than 1 in order to 
free the page. My rationale here is that before CoW was implemented in xv6, 
each page would have 1 reference at all times, and kfree() was called on pages 
that had 1 reference. So in order for all the pre-existing calls to kfree() to 
function correctly, it has to decrement the reference count by 1 before it 
attempts to free the page. kalloc() re-initializes the reference count for the
newly allocated page to 1. All of these operations are performed with the
kernel memory data structure lock held.
I also created three functions concerning the physical page reference count.
ref_inc() increments the reference count. ref_dec() decrements the reference 
count. ref_cnt() returns the reference count. All three functions take the 
physical address as a void pointer, which is the same size as anything that 
might be passed in (struct run*, char*, uint64, etc). These functions are all 
designed in such a way that they can be called inside or outside of critical 
sections, and function the same way (since they need to hold the lock).

uvmcopy()
The changes to this function were minor but massively important. Instead of
allocating a new page, copying the data to it, and mapping it to the child’s
page table, this function first increases the number of references for the 
parent’s page. Then it flips the PTE_W bit, and the newly created PTE_COW bit 
(indicating that the page is copy-on-write) that I defined as bit 8 of the 
flag bits (bits 8 and 9 were free to use according to the documentation) in 
riscv.h. This special bit is necessary to differentiate between normal 
read-only pages and copy-on-write pages. It extracts the flag bits using 
the PTE_FLAGS macro and assigns them to the flags variable, then it maps
the parents page into the child's page table and flushes the tlb using
sfence_vma() from riscv.h (the name is not very descriptive, but there 
is a comment there that says it flushes the tlb, so that’s what I used).


Page Fault Handler in usertrap()
The xv6 book describes three different types of page faults, and my initial 
attempts to handle all three were not very successful. Based on advice from 
a TA I determined that I only needed to create a condition to handle 
r_scause() == 15. When this type of page fault occurs (a store/AMO page fault)
the first thing I do is get the faulting address using r_stval(), round it 
down using the PGROUNDDOWN macro, and assign it to va. Then I use walk to get
the specific page table entry.
I check if the page table entry is valid, then I check the flag bits to ensure
it is a valid page, it is a user page, and it is a copy-on-write page. If the
reference count of the page is 1, I simply flip the PTE_W and PTE_COW bits.
Otherwise, I decrease the reference count of the page, get the flags and flip 
the write and copy-on-write bits, then allocate a new page and copy the memory 
from the existing page to it. Then I unmap the old page and remap the new page.
If the pte does not point to a user page that is copy-on-write, I print an 
error message, and kill the process.

copyout()
When data is copied out of the kernel to a user page, it may try to copy to a
page that is copy-on-write, so I needed to implement the same page fault 
handling process in copyout(). I check if the page is copy-on-write and 
read-only. If it is, I check the reference count and flip the bits if it's 1.
Otherwise I decrease the reference count, allocate a new page, get the flags
and flip the necessary bits, and move the information from the old page to the
newly allocated one. Then I unmap the old page from the page table and map the 
new page. Then I set pa0 = mem (the new page) so the rest of the function works
the same.

