

Old scheduler: handler switches to the kernel scheduler, which then selects

the first available process to run. 



* Assume process with single thread only

New scheduler:  schedule processs based on fair shares of the CPU

    - Each process has a share
            ---> Try to look into the structure of the fork () return value
            ---> Might make changes in there to create a random number of 
            
            share.

                  A    B   C        Total 
Pre-share        100   50  75       225

Percentage       44%   22% 33%
important        
(CPU times)

Possible        A A C B A A B C .....
sequence 



    - Scheduler must ensure that the number of quanta a process has been 
      
      allocated  " stay near " its predefined share


    Ready queue: only store RUNNABLE processes

    - if a process calls sleep(), it should not stay in the ready queue

    ---> Can use monitor to store the process which put to sleep

    

    - Scheduler should put processes just created or woken up to the 

    back of the ready queue

    ---> ListPrepend(), ListTrim()




Test: user program

    call fork() to generare children:
        - children sleep for a rand()
        
        - woken up and compute square () for a random number of calls


--> "Verify that some "group" of processes as you have defined it gets a

"share" of the CPU as you defined. 



