getNumFreePages
walk the page table and determine how many free pages are available
- page table has three levels with 512 pages each
  - each entry in the top two levels is a page table in the lower level
  - each process has its own page table - meaning it owns a page table entry in
    the top level or the middle level
  - lower level page table entries are prioritized before upper levels
    - meaning that upper levels should not need to be traversed as far

refCount
add a kernel data structure that keeps track of the reference count of pages,
and functions to increment and decrement these counts
- reference count of a page should be decremented when a process referencing it
  gets its own copy (a new copy) of the page when it is copied when that process
  needs to write to it
- a page can be freed when no process is pointing to it anymore (reference count
  equals 0)
- consider all situations where reference counts should be incremented and decremented
- make sure locks are held when incrementing and decrementing

uvmcopy
change to implement copy on write
- page tables of the parent and child should point to the same physical page
- those pages should be marked as read-only
- parent's page table must be reinstalled and TLB entries must be flushed
- reference count of kernel pages may need to be incremented here

trap handler (page fault handler)
add a trap handler to handle page faults
- when parent or child processes attempt to write to a page marked read-only
  the resulting page fault needs to be handled (this is when the page must be
  copied)
- initial implementation can print an error message
- for final implementation the trap handling code should call the function that
  makes a copy of the user pages
- when a page fault occurs stval register holds the faulting virtual address
  - can be retrieved using r_stval()
  - examine that virtual address and decide what should be done
    - if the virtual address is in the illegal range of addresses that aren't
      mapped in the processes page table print an error and kill the process
    - if the trap was generated due to an attempt to write to a page marked as
      read-only, then the page must be copied
- between the parent and the child, the first one that tries to write a page should
  get a new page (which is copied from the contents of the original page pointed to
  by the virtual address)
  - the original page is still marked as read-only, so when the other process needs
    to write, it can be marked as writeable (instead of creating a new page)
    - page fault handling code should distinguish between those two cases using the
      reference count variable
    - so reference counts need to be accurate
    - remember to flush the TLB whenever page table entries are changed

cowtest
integrate(create?) a program to test the copy-on-write implementation
