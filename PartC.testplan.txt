CMPT332 - Group 14
Phong Thanh Nguyen (David) - wdz468 - 11310824
Woody Morrice - wam553 - 11071060

For Phase 2: 

For every test cases, there will be a message to indicate what it is doing

and a result: passed! / Not passed!.

To a point where we have "out of memory", simply print out the error message

indicating the adding function return -1 and cannot add anymore.


For Phase 3: 
Changed the test case to match with the latest advice to make the test result 
become more details 

When memory exceed, everything after that will return NULL in order not to make
the program crashes. 

# ListCreate()

    For this function, I basically check if the reference returns a NULL
    
    pointer, if it returns NULL that mean the functions is not working properly

# ListCount()
    For this function, simply check the return value of the (list->totalItem).

# ListAdd()

    Since the function supposed to add new item directly after current item. 

    There are some scenarioes that we can check: 
    
        First, if the (list->totalItem) equals zero, then we make the new item
        
        to be both the head and tail. If the (list->headPointer) and 

        (list->tailPointer) return NULL, means the functions is not adding
        
        and fail to assign the value to head and tail pointer. 

        

        Second, if (list->currentItem) is at (list->tailPointer), the function
        
        should make the newItem the new tail and check for number of totalItem

        (Check for tail value if it is pointing to newItem and totalItem)

        
        
        Finally, if (currentItem) is at the middle, we check for the

        (newItem->prevNode), (newItem->nextNode) to make sure the function
        
        is inserting the newItem at the proper position. 
         
  

# ListAppend()

    Since the function supposed to add newItem to become the new tail.

    There are some scenarioes that we can check:

        First, if the (list->totalItem) equals zero, then we make the new item

        to be both the head and tail. If the (list->headPointer) and

        (list->tailPointer) return NULL, means the functions is not adding

        and fail to assign the value to head and tail pointer.



        Second, we always want to make sure the (currentItem) is always at the
    
        end of the List or not pointing to NULL , simply check for the 

        new (list->tailPointer) and the (totalItem) when adding newItem, 

        if does not pass, mean the function does not work correctly.


# ListPrepend()

    Since the function supposed to add newItem to become the new head.

    There are some scenarioes that we can check:

        First, if the (list->totalItem) equals zero, then we make the new item

        to be both the head and tail. If the (list->headPointer) and

        (list->tailPointer) return NULL, means the functions is not adding

        and fail to assign the value to head and tail pointer.



        Second, we always want to make sure the (currentItem) is always at the

        start of the List or not pointing to NULL, simply check for the 

        new (list->headPointer) and the (totalItem) when adding newItem, 

        if does not pass, mean the function does not work correctly.

        
# ListInsert()

    Since the function supposed to add new item directly before current item.

    There are some scenarioes that we can check:

        First, if the (list->totalItem) equals zero, then we make the new item

        to be both the head and tail. If the (list->headPointer) and

        (list->tailPointer) return NULL, means the functions is not adding

        and fail to assign the value to head and tail pointer.



        Second, if (list->currentItem) is at (list->headPointer), the function

        should make the newItem the new head and check for number of totalItem

        (Check for head value if it is pointing to newItem and totalItem)



        Finally, if (currentItem) is at the middle, we check for the

        (newItem->prevNode), (newItem->nextNode) to make sure the function

        is inserting the newItem at the proper position.

# ListConcat()

    This function is to concatenate the given 2 lists and delete the second 

    list. First, I will check if two actual valid lists can concatenate

    probably, the test checks on the totalItem, head pointer, tail pointer

    their linking and double check again to see if the second list is deleted

    or not. In order to confirm second list is deleted, I will look into the 

    variable memoryListUsed and curFreeList.

# ListRemove()
        
    Since this function is to remove the item where the current cursor is
    
    pointing at and make the next item the current one. 

    I will do the test as following: 
    
        First, call function to delete on an empty list, and check if the value
        
        return is a NULL or not.

        Second, remove an item when the current list has 1 item, the function
        
        should return NULL because there is no other item in the list. I also

        will check on the list total item and check on current free node to see

        if that item is actually deleted.

        Finally, I will operate multiple ListRemove() on a list that contains

        multiple items and check for return value, as well as if the current 

        free node space is linking probably or not.

# ListFree()

    This function is supposed to delete a list and free all the item in there.

    I created 2 functions in the main test file one for itemFreeChar() and 

    itemFreeInt() because my list mostly contain 'int' or 'char'.

        To check if this is actually work, assume we will never use the
    
        variable that points to the list that we created at first, I will 

        check if the function returns the right data type and check if that 

        item changed its value to indicate that they are deleted out of the 

        list. '&' for deleted 'char' and '-1' for deleted 'int'

# ListTrim()

    This function will delete the last item in the list and make the previous
    
    become the new tail. For that, I will check the for totalItem remains,

    new tail value to see if they actually acquire new tail, current free node

    space and finally the linking of newTail to other nodes. Also check for 

    some special case, such as trimming an empty list, trimming list that has

    one item. 

# ListSearch()

    This function returns the dataType of item if it found a match, otherwise 

    return a NULL and left the current pointer at the end of list. I will 

    check when the item actually exists in the list and when that item does

    not exist in the list, based on the return value, we can determine if the

    function is working probably.

 
