# CMPT332 - Group 14
# Phong Thanh Nguyen (David) - wdz468 - 11310824
# Woody Morrice - wam553 - 11071060

# Part E Test Plan and Test Results

# Test Plan
To show that our implementation of trace works properly
we will need to test that the input is interpreted properly
by the program, that the program rejects improper input,
and that it works for tracing the first and last system
calls (then we can assume it works for every system call
in between). We should also show that trace outputs nothing
when it is not invoked. We will assume the demonstrated
output in the assignment spec is correct and compare our
output to that, and we will perform a couple extra tests
using erroneous input.

Input will be entered directly into the xv6 console, and
output will be read directly from console output. Note that
test output may differ by some process IDs and return
values.

# Test 1
Input: trace 32 grep hello README
Expected Output:
3: syscall read -> 1023
3: syscall read -> 966
3: syscall read -> 70
3: syscall read -> 0

Show that the integer input is being
interpreted correctly.

# Test 2
Input: trace 2147483647 grep hello README
Expected Output:
4: syscall trace -> 0
4: syscall exec -> 3
4: syscall open -> 3
4: syscall read -> 1023
4: syscall read -> 966
4: syscall read -> 70
4: syscall read -> 0
4: syscall close -> 0

Shows that a range of different system calls
(including the last one in the list, trace())
are properly interpreted through the bitmask
and displayed.

# Test 3
Input: grep hello README
Expected Output:
<None>

Shows that when trace is not explicitly called,
there is no extra outputput to the console.

# Test 4
Input: trace 2 usertests forkforkfork
Expected Output:
usertests starting
test forkforkfork: 407: syscall fork -> 408
408: syscall fork -> 409
409: syscall fork -> 410
410: syscall fork -> 411
409: syscall fork -> 412
410: syscall fork -> 413
409: syscall fork -> 414
411: syscall fork -> 415
...

Shows that the first system call in the list
is properly traced.

# Test 5
Input: trace notanumber echo whoops
Expected Output:
trace user program rejects input

Any time a user program evokes a system call
it should explicitly ensure it is passing the
correct input.

# Test 6
Input: trace 0 echo hello
Expected Output:
hello

If the bitmask is 0 then no system calls
should be traced, and it should act the same
as if it were never called at all.



# Test Output

xv6 kernel is booting

hart 2 starting
hart 1 starting
init: starting sh
$ trace 32 grep hello README
3: syscall read -> 1023
3: syscall read -> 961
3: syscall read -> 321
3: syscall read -> 0
$ trace 2147483647 grep hello README
4: syscall trace -> 0
4: syscall exec -> 3
4: syscall open -> 3
4: syscall read -> 1023
4: syscall read -> 961
4: syscall read -> 321
4: syscall read -> 0
4: syscall close -> 0
$ grep hello README
6: syscall fork -> 7
test forkforkfork: 6: syscall fork -> 8
8: syscall fork -> 9
9: syscall fork -> 10
9: syscall fork -> 11
10: syscall fork -> 12
9: syscall fork -> 13
11: syscall fork -> 14
10: syscall fork -> 15
12: syscall fork -> 16
9: syscall fork -> 17
10: syscall fork -> 18
11: syscall fork -> 19
12: syscall fork -> 20
9: syscall fork -> 21
...
12: syscall fork -> -1
OK
6: syscall fork -> 69
ALL TESTS PASSED
$ trace notanumber echo whoops
Usage: trace mask command
$ trace 0 echo hello
hello


All tests resulted in expected output so trace
appears to be working properly.
