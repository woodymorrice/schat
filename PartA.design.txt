# CMPT332 - Group 14
# Phong Thanh Nguyen (David) - wdz468 - 11310824
# Woody Morrice - wam553 - 11071060

# Design Documentation for Part A

# Work Plan
Woody will be in charge of design and implementation for part A.

# Design Details
The overall design for Part A is relatively simple and straightforward,
with most of the details outlined in the assignment spec. All that was
really left up to us was to decide on the details of the implementation.
Each portion (A.1, A.2, etc) will have its own source file and will be
compiled into a separate executable so that they can each be run 
independently of each other, and will have no interface or interaction
between them. The general code structure for each portion will be similar.
The main function will ensure that three command line arguments were given
and check them for validity. It will then create the 'parent' thread and
pass the arguments to it, check that the thread was created successfully,
then sleep until the deadline. When the deadline is reached, the main
function will exit. The parent thread will create the specified number of
child threads, ensuring they are created successfully, then sleep until 
the deadline. When the deadline is reached the parent thread will notify 
the child threads, then exit. The child threads will record their thread
id and the time at which they were created, then begin calling the square
function in a loop. The loop will end when the square calculations have
completed, or when the parent thread signals that the deadline has been
reached. At that point, the child thread will print the number of times
its particular instance of the square function was called, and its elapsed
run time, then it will exit. The square function will calculate its output
recursively, recording the number of times it is called.

# Implementation Details
# All Parts
The command line arguments will be stored in an array by the main function,
and the address of the array will be passed to the created threads. If any
of the provided arguments are not within the acceptable range, the program
will exit silently but emit an exit code that indicates the program did
not complete its operations successfully. Child thread information will
be stored in an array of threadInfo objects with three fields: threadId 
will store the thread identifier as an unsigned long integer, beginTime
will store the system time when the thread was created as an unsigned long
integer, and sqCalls will store the number of calls to the square function
from that thread as an unsigned integer. The array will hold a maximum of
64 threads. Child threads will be stored in the array in the order they
are created, and indexed by comparing their thread ID obtained with
getThrId() with the thread ID stored in their corresponding threadInfo object.
The square() function will be located in the square.c source file and
included via the square.h header file and should not need to be modified
for any of the individual parts of part A.
Each individual part of A will implement the getThrId function which will
call its API specific function to retrieve the thread id, and return it as
an unsigned long integer.
After the deadline is reached, the program will sleep for an additional
2 seconds to allow child threads to print to the console.


# A1
Each thread will be created with a stack size of 1 mb, which will allow
a size argument of up to 20000 without causing an overflow. The main
function and parent thread will call the Sleep() function to wait until
the deadline. The SYSTEMTIME structure documentation page located at
learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-systemtime
explains not to use the GetSystemTime() function to determine elapsed time,
and refers to the Windows Time page
learn.microsoft.com/en-us/windows/win32/sysinfo/windows-time
that suggests using some combination of the GetTickCount, GetTickCount64
and GetMessageTime functions. I chose to use GetTickCount64() since there
could be some problems with time wrap around using the normal GetTickCount()
function if the computers in the Spinks lab haven't been restarted recently
enough.

# Function Specifics
# DWORD WINAPI parentThread(LPVOID lPtr)
Preconditions: Command line parameters must be integers of an appropriate
size. Appropriate size will be determined during implementation.
Postconditions: Child threads must complete and call exit().

# DWORD WINAPI childThread(LPVOID lPtr)
Preconditions: Parameters passed from parentThread should be valid and
appropriate.
Postconditions: keepRunning global variable must be set to false.

# int square(int n)
Preconditions: n must be a positive integer.
Postconditions: n == 0

# unsigned long int getThrId()
Preconditions: none
Postconditions: none


# A2
Child threads are created with a stack size of 1 mb for consistency with
part A1 and so that the test parameters are the same. I used Time()
from ubc pthreads at the beginning and end of child thread execution
and took the difference. I casted the output of MyPid() to unsigned
to keep it consistent with part A1. The parent thread is created with
HIGH priority allowing it to create all the child threads without
being bogged down by their calculations, but as a result the child
threads' running time may be shorter.

# PROCESS parentThread(void* argPtr)
Preconditions: Command line parameters must be integers
Postconditions: Child threads must complete and output to console, or
be killed and parentThread prints their output.

# PROCESS childThread(void* argPtr)
Preconditions: Parameters passed from parentThread should be valid and
appropriate.
Postconditions: Must output to console or be killed by parent.

# int square(int n)
Preconditions: n must be a positive integer.
Postconditions: n == 0

# unsigned long int getThrId()
Preconditions: none
Postconditions: none

# A3
I wanted to maintain code clarity and avoid using posix
thread attribute objects, and according to
https://man7.org/linux/man-pages/man3/pthread_create.3.html
the default stack size is 2 mb on x86_64 architecture. Since
that is more than sufficient for consistency in testing maximum
values for inputs with the other parts of part A, I kept the
default value. I used a couple extra functions here: cHandler()
is a signal handler function that terminates the child threads
when the deadline is reached, and getMs() is a function that
parses the output of the clock_gettime into a value in ms
with enough resolution to track the thread running time at the
maximum deadline value. The implementation here is similar to A2
where the parent thread kills the child threads if the deadline
is reached, the main difference is that pthread_kill sends a
signal (ubc pthreads kill() does not as far as I know). This
implementation also uses one extra global array, thrOut, where
each child thread toggles a boolean just before they output to
the console. The parent thread checks those booleans when it is
killing the remaining child threads after the deadline to ensure
that no thread output is printed twice.

# void* parentThread(void *argPtr);
Preconditions: Command line parameters must be integers
Postconditions: Child threads must complete and output to console, or
be killed and parentThread prints their output.

# void* childThread(void *argPtr);
Preconditions: Parameters passed from parentThread should be valid and
appropriate.
Postconditions: Must output to console or be killed by parent.

# int square(int n)
Preconditions: n must be a positive integer.
Postconditions: n == 0

# unsigned long int getThrId();
Preconditions: none
Postconditions: none

# void cHandler(int n);
Preconditions: Thread must receive a signal
Postconditions: Thread must exit

# int getMs();
Preconditions: none
Postconditions: none

# A4
Pending implementation...

