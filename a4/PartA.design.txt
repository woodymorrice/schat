# CMPT332 - Group 14
# Phong Thanh Nguyen (David) - wdz468 - 11310824
# Woody Morrice - wam553 - 11071060

Memory Management Simulation

Special Notes
Important and not-so-important defines are gathered in the defs.h header. This
header contains all the important test parameters that we would modify during
our tests.

We chose not to try to run the test concurrently because there is only one
monitor, and if both tests were waiting on the same monitor it could skew the
results depending on how the threads were scheduled by RttThreads. So we made
it so the random numbers could be preserved as files and each test would be a
single execution of the test program. As detailed in the design, the program
can be told whether to generate new random numbers, or simply use the existing
ones. So we would test by generating a new set or random numbers and running
the best fit test, then running the first fit test with the same set of random
numbers before generating new numbers for the next test.

The spec mentions that threads should randomly choose to free and continue to
free after all requests were finished. We noticed a problem with that idea
though. At what point do we get our statistics? If we wait until all threads
have finished their sets of requests, suppose that one thread randomly had to
sleep for much longer than other threads. When it was eventually the last 
thread that finished, it would output the current state of the memory 
structure, but by that point all the other threads would have started 
continuously freeing, leave the block structure in a mostly empty state, and 
then we would have no information about fragmentation. We wanted to draw our 
tests results from a consistent, predictable point in execution, so we chose 
to only have each thread run as long as it had requests to process. When it 
finishes its list of requests, it exits, and when all threads finish all 
requests, the program outputs the test statistics.


Design Details
Our memory management simulator, memsim.c, is an improved version of our lab6 
implementation of the memory allocation simulator. It uses the existing best 
fit implementation (with some minor improvements) and can be used to compare 
its performance to the first fit algorithm.

memmonitor.c
A list is used to store the total system memory (like in lab6), and each 
individual block of memory is a node on that list, implemented as a structure 
that holds three integers: isFree indicates whether or not the block is a free 
block, startAddr indicates the address in memory where that block begins, and 
size is the total size of that memory block. 
A structure memStruct is used to store the list of memory blocks, as well as 
several pieces of information about the simulation that can be retrieved using 
MyMemStats().
memmonitor.c contains the functions that operate on the memory structure. 
memInit() is called once at the beginning of the simulation, and initializes 
the memStruct used for the test. It also inserts the initial block of memory, 
which is a big free block that is the entire memory size.
MyMalloc() is designed according to the assignment specification - it returns 
a void pointer to the chosen memory block like the unix malloc(), and takes 
two integers as parameters, the size of the block to allocate, and the 
algorithm to use to find the block. It functions by calling bestFit() or 
firstFit() based on the value of the alg parameter in a loop, and calling 
RttMonWait() if no appropriate block can be found. If/when a block is found, 
it updates the necessary statistics and returns the block back to the calling 
thread.
bestFit() takes one argument, the size of the block to allocate, and functions
as a best fit algorithm should. It checks each free block in the entire memory
structure and returns the one whos size is closest to the requested size. When
a block is found, it inserts the new allocated block before it in the list, 
subtracts the size of the new block from the found free block and adjusts its 
starting address. If no block can be found, it returns NULL (causing MyMalloc()
to call RttMonWait()).
firstFit() functions the same as bestFit() in every way except for the way that
it finds a block. It will only iterate through the memory structure until it 
finds the first free block bigger than the requested size, and uses that.
MyFree() functions exactly as outlined in the assignment spec except for one 
small difference. The unix free() does not return anything (void), but I wanted
MyFree() to give us some indication when we were debugging if it could not find
the block to free for some reason, so I implemented it to return an integer (0 
on success, 1 on failure) instead. It takes a single argument, a void pointer 
to the memory block to free. It iterates through the memory structure until it 
finds the block to free, when it finds it, it updates the relevant statistics, 
coalesces any adjacent free blocks, and calls RttMonSignal() to wake the thread
waiting to allocate at the start of that queue.
MyMemStats is designed exactly according to the assignment specification. It 
returns a void pointer to a memStat structure that records relevant statistics. 
It takes three arguments, alg, an integer that specifies which algorithm to 
return the stats for, stat, an integer that specifies which statistic to
return,and a void pointer to the memStat structure to store the information in.
MyMalloc(), MyFree() and MyMemStats() all call RttMonEnter() before performing 
any operations on the memory structure, and call RttMonLeave() when they are 
finished.

memsim.c
memsim.c is designed to take up to three command line arguments. The first 
argument is the number of requests to run for the test (which must be specified 
at run time). The second argument is the algorithm to run the test with. 0 will 
run the best fit algorithm, 1 will run the first fit algorithm, this is set to 
0 by default. The third argument is a boolean value that determines whether the
program should generate new random numbers or not. 0 tells the program not to 
generate new random numbers, 1 tells it yes. This is set to 1 by default.
After the arguments are processed and checked for validity, the program 
conditionally generates the random numbers for the test.
gen_rands() returns an integer to indicate success, and takes a single integer 
argument, the number of requests. First it chooses a random seed (determined 
by a call to time()), then for each allocator thread it will generate a set of 
random numbers. Random number sets are stored in text files that are stored 
in the /tmp/ folder, so the gen_rands() will first check if that folder exists,
and if it does not, it will create it. It will name each file using the value 
of i  in the for loop(from 0 to NUM_THRDS-1). Then it calls fopen(), creating 
that file if it does not exist, and for each request, it generates three random
numbers. First it generates essentially a boolean value, a 1 or a 0, which 
determines whether that request is an allocation or a free. It generates that 
number using the simple uniform distribution provided by the rand() function. 
Next it generates the allocation size (which it simply ignores during execution
if the request is a free) using a random number determined with a normal 
distribution. The third number it generates is the sleep time, which is 
generated using a random number generator with an exponential distribution. 
The random number generator functions are located in random.c and are 
implemented according to the directions in the appendix of the assignment 
specification. Once three numbers are generated for each request, it closes 
the file and returns.
After the random number sets are generated (if necessary), the algorithm 
initializes the allocator threads, and one other special thread. init_thrds()
first calls memInit() to initialize the memory structure, then creates
NUM_THRDS threads. The allocator threads run the sim_proc() function and are
passed two arguments: the integer indicating the algorithm, and i which ranges
from 0 to NUM_THRDS and allows the threads to know which set of random numbers
to read from.
Then the algorithm initializes a low priority thread that runs the function
getInput().
sim_proc() initializes a list to store its allocated blocks of memory. Then
it uses the i that was passed in to determine which random number file to read
from, opens, it, and starts processing the requests. As its iterating through
the random numbers, it simply takes the modulo of the counting variable to know
what random number it is reading. So if the counting variable is divisible by
3, it knows that is the random number that tells it whether the current request
is an allocation or a free. If i % 3 == 1, it knows the random number is the
size of the block to allocate (or it just skips this number if the current
request is a free). Then it either calls MyMalloc() with the random number as
the size, or it randomly picks a block from the list of blocks it currently
holds to free. If i % 3 == 2, it knows that the random number indicates the
amount of time it should sleep. Because we wanted the tests to be able to be
completed in a reasonable amount of time the threads call RttUSleep() instead
of RttSleep(), because when the program is processing 1000-10000 requests, even
sleeping for 1 second is too long.
After all the requests have been processed, the thread frees the space that was
allocated for its arguments, closes the file descriptor it was reading from,
then increments a global integer called fin. This global integer records how
many threads have finished, and each thread checks it before they exit. If
fin == NUM_THRDS, MyMemStats() is called to emit the statistics of the test,
and the program exits.
getInput() listens for input from the keyboard, allowing the user to type
“stats” to get the stats from MyMemStats() at any point during the experiment.
The user can also type “exit” or “quit” to end the experiment prematurely.

