* CMPT332 - Group 14
* Phong Thanh Nguyen (David) - wdz468 - 11310824
* Woody Morrice - wam553 - 11071060

** Best-fit Memory Allocation Simulator **
**            Design Details            **


BestFitMonitor.h

    struct memBlock:
        isFree -- boolean that indicates whether the block is free or not
        startAddr -- int representing the address where the block starts
        size -- int representing the size of the block

    Function prototypes:
    
        int BestFitInit();                    // initialize the list storage 
                                              and first block in the list

        struct memBlock* BFAllocated(int);    // create new block based on the
                                              given size

        int Free(int);                        // free the block based on the 
                                              given address

        void memPrinter();                    // print out the status of the 
                                              blocks in memory



BestFit.c - implementation of threads
    
    The size of each new block allocated is randomly determined using 
    rand() % MAX_ALLOC. Each thread loops 8 times (NUM_ITERS) and each loop
    the thread randomly decides whether to allocate a memory block with
    BFAllocate() or free a block with Free() (50% chance each specified by
    FREE_PROB). MAX_ALLOC defines the maximum possible block size as
    8192(2^13), which is limited to 1/4 of the total available memory to
    prevent excessively large blocks from being allocated and ruining the
    demonstration. After allocating or freeing, each thread will sleep for a
    random amount of time based on MAX_SLEEP.  


    RTTTHREAD simProc (void *arg):
        create list for blocks allocated by this process 
        repeat NUM_ITERS times
            randomly set size
            randomly choose to free or allocate
            if chose to allocate
                BFAllocate(size)
                if allocate successful
                    add block to list
            else
                if list is not empty
                    randomly choose a block in the list to free
                    Free(block)
                    remove block from list
            sleep for a random amount of time



BestFitMonitor.c - implementation of monitor procedures BF-Allocate & Free
    A linked list is used to represent the total available memory, where each
    individual block of memory is represented by a list node. Each list node
    is a pointer to a memBlock struct that contains all the necessary
    information. The blocks are stored in increasing order based on memory
    address. After the list is initialized a single block is created that
    represents the entire free memory space before any allocations have
    occured.


    int BestFitInit ():
        initialize the monitor
        create memory block list
        create the initial block of memory 


    memBlock* BFAllocate (int size) {
        MonEnter()
        while best-fit block has not been found {
            while not at the end of the list
                iterate through the list
                find the best-fit block
            if no suitable block can be found
                MonWait()
        create a new allocated block
        subtract new block size from the best-fit block
        set new block start address to the best-fit block start address
        set best-fit block address += new block size
        allocate space in the best-fit block
        insert new block into list in front of best-fit block
        memPrinter()
        MonLeave()
        return pointer to new block


    int Free (int address) {
        MonEnter()
        while not at the end of the list
            iterate through the list
            if block start address == address argument
                set block to free
                if previous block exists and is free
                    set current block start address to prev block start address
                    set current block size += prev block size
                    remove previous block from list
                if next block exists and is free
                    set current block size += next block size
                    remove next block from list
            memPrinter()
            MonSignal()
            MonLeave()
            return success
        MonLeave()
        return failure


    void memPrinter():
        print visual representation of memory space

