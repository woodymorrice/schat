* CMPT332 - Group 14
* Phong Thanh Nguyen (David) - wdz468 - 11310824
* Woody Morrice - wam553 - 11071060


** Design Details **
File (monitor.c) will consists of 5 functions: 

MonInit() - will intialized all the needed condition queues, enter queue 
and urgent queue. Create the semaphore for each of the queue that exists. 

MonEnter() - check the mutex lock and decide whether the new thread is 
allow to enter. Function will return an integer value, 0 for success entering, 
otherwise return -1 for failure.  

MonLeave() - will responsible for releasing the mutex lock on the monitor, 
checking whether if there are any other waiting threads in urgent queue, and 
wake it up. If there is no thread waiting on urgent queue, simply do nothing. 
Return 0 for success leaving, and -1 otherwise. 

MonWait(int CV) - making the current thread to wait on the condition queue.
Release the mutex lock so another thread can enter. The thread waiting on
condition queue will have no effect on the monitor, until another new thread
enters and wakes it up.

MonSignal(int CV) - waking up the waiting thread of that condition variable
in the condition queue. If there is no thread waiting on that condition, the 
function simply does nothing. Else, put the current thread that is calling 
the function in the urgent queue. Now the monitor is only released when the 
thread in urgent enter the monitor again using MonEnter()  and  leave the 
monitor by calling MonLeave(). Enforce the idea when the last person leave
Saskatoon, turn off the light.  

Assume all the created thread will be at user-level threads. 

** Pseudocode **

int MonInit(int numConds) {
    create the condition queue based on the parameter
    for every condition queue
        create new semaphore by using RttNewSem()
    create enter queue semaphore
    create urgent queue semaphore
    create a semaphore for mutex
    return 0 (on success) / -1 (on failure)
}

int MonEnter() {
    check if the mutex lock is released
    if (mutex is released) { 
        new thread enter the monitor
    } 
    else {
        making the new thread wait in the entering queue
        return -1
    }
    lock the monitor to prevent other threads to enter
    return 0 (success)
}
    
int MonLeave() {
    check if there are waiting thread in the urgent queue
    if (there are no waiting thread) {
        do nothing
    }
    else {
       signal to wake up the waiting threads
    }
    release mutex lock 
    return 0 (leave success) / -1 (leave failure)
}

int MonWait(int CV) {
    make current thread wait on the CV
    release mutex lock
    return 0 (if the passed argument is valid) / -1 (otherwise) 
}

int  MonSignal(int CV) {
    if (no thread is waiting on CV) {
        do nothing
    }
    else {
        wake up the waiting thread of that CV
        put the current thread into the urgen queue 
    }
    return 0 (if the passed in argument is valid) / -1 (otherwise)
}

